# settings
set export := true
set positional-arguments

CROSSFILE := "Crossfile"
CROSSDIR := ".git/cross"
METADATA := "$CROSSDIR/metadata.json"
JUST_DIR := env("JUST_DIR", source_dir())
REPO_DIR := env ("REPO_DIR", "$(git rev-parse --show-toplevel)")
SHELL := env("SHELL")
dry := ""


# Auto-setup environment on first use
# AICONTEXT: Optional target to help user to ensure correct setup for tool usage. Taks: Call direnv, loading .envrc and from that .env file. Ideally short implementation. 
setup:
    #!/usr/bin/env fish
    # Check if direnv is available
    if command -v direnv >/dev/null; and test -f .envrc
        if not direnv status | grep -q "Found RC allowed true"
            direnv allow .
        end
    end

# AICONTEXT: Implemented through just -l option. Use comment strings on individual targets to document ussage.
# Show this help message
help:
   just -l

# AICONTEXT: This is for AI tools to execute tests in sanbox environment. Do not change implementation!
# Run test suite in clean environment (optional args: [test_id]: 01, 02, etc)
test *ARGS:
    #!/usr/bin/env bash
    # PRESERVE THESE ENVS
    THOME="$HOME"
    TUSER="$USER"
    TPATH="$PATH"
    TTERM="$TERM"
    BASH="$(command -v bash)"

    if [[ "${1:-}" == "shell" ]]; then
        shift || true
        just --justfile "{{JUST_DIR}}/Justfile.cross" test-shell {{ARGS}}
        exit 0
    fi

    # Run in clean environment with minimal PATH
    #TARG="${ARGS:+--test $ARGS}"
    env -i \
        TARG="$TARG" \
        HOME="$THOME" \
        USER="$TUSER" \
        PATH="$TPATH" \
        SHELL="$BASH" \
        TERM="${TTERM:-xterm}" \
        GIT_CONFIG_NOSYSTEM=1 \
        GIT_CONFIG_GLOBAL=/dev/null \
        "$BASH" --norc --noprofile -c 'cd "{{JUST_DIR}}"; ./test/run-all.sh {{ARGS}}';
    STATUS=$?
    echo "Test exited with $STATUS";
    exit $STATUS

# AICONTEXT: This is for AI tools to execute tests in sanbox environment. Do not change implementation!
# Run "test" shell environment or commands passed as ARGS inside "test shell environment"
test-shell *ARGS="bash":
    #!/usr/bin/env bash
    set -euo pipefail
    THOME="$HOME"
    TUSER="$USER"
    TPATH="$PATH"
    TTERM="$TERM"
    BASH="$(command -v bash)"

    if [[ -t 0 && -t 1 ]]; then
        echo 'Launching git-cross test shell (type CTRL+D to leave)...'
        env -i \
            HOME="$THOME" \
            USER="$TUSER" \
            PATH="$TPATH" \
            SHELL="$BASH" \
            TERM="${TTERM:-xterm}" \
            "$BASH" --norc --noprofile -i -c "{{ARGS}}"
    fi

# AICONTEXT: This methond validate user workspace has installed all required dependencies. Dont install them, but prints how-to.
# Check for required dependencies
check-deps:
    #!/usr/bin/env fish
    set -l missing
    for cmd in fish rsync git jq
        if not command -v $cmd > /dev/null
            set missing $missing $cmd
        end
    end
    if test (count $missing) -gt 0
        just cross _log error "Missing: $missing"
        just cross _log info "Install with: brew install $missing"
        exit 1
    end


# AICONTEXT: This is new and better implementation of resolve_context
# Internal: resolve patch metadata from path argument or CWD
[no-cd] # to be able to set CWD as $path if not provided
_resolve_context2 path="": check-initialized
    #!/usr/bin/env fish

    # Resolve git repo relative path of target
    if test -z "$path"
        set -x path "$(git rev-parse --show-prefix | sed 's,\/$,,')" # cwd, relative to git repo
    end
    if test -z "$path"
        just cross _log error "Provide path to 'patch' or change directory into it."
        exit 1
    end
    # Query metadata.json and export matching key as env variables
    # Find patch where local_path matches rel_target or is a parent of rel_target
    jq -r --arg path "{{path}}" '
        .patches
        | map(. as $patch | select($patch.local_path | startswith($path)))
        | map(. + {mlen:(.local_path|length)})
        | max_by(.mlen)
        | to_entries | map("set -x \(.key) \(.value|@sh)") | .[]
        ' "{{REPO_DIR}}/{{METADATA}}"

# AICONTEXT: This method updates Crossfile, an configuration file for git-cross. Do not change implementation!
# Internal: append command to Crossfile (avoiding duplicates)
update_crossfile +cmd:
    grep -qF "{{cmd}}" "{{CROSSFILE}}" 2>/dev/null || echo "{{cmd}}" >> "{{CROSSFILE}}"; exit 0


# Internal: Log message with color
_log level +message:
    #!/usr/bin/env fish
    set color_reset (set_color normal)
    switch {{level}}
        case info
            set color (set_color blue)
            echo "$color==> {{message}}$color_reset"
        case success
            set color (set_color green)
            echo "$color==> {{message}}$color_reset"
        case warn
            set color (set_color yellow)
            echo "$color==> WARNING: {{message}}$color_reset"
        case error
            set color (set_color red)
            echo "$color==> ERROR: {{message}}$color_reset" >&2
        case '*'
            echo "==> {{message}}"
    end

# Execute arbitrary shell command
exec +CMD:
    {{CMD}}

# Initialize a new project with Crossfile
[no-cd]
init:
    #!/usr/bin/env fish
    if test -f "{{CROSSFILE}}"
        just cross _log info "Crossfile already exists."
    else
        echo "# git-cross configuration" > "{{CROSSFILE}}"
        just cross _log success "Crossfile initialized."
    end

# AICONTEXT: "use" register remote git repository and update Crossfile with "use" command. Do not change implementation!
# Add a remote repository
[no-cd]
use name url: check-deps
    #!/usr/bin/env fish
    cd "{{REPO_DIR}}" &&\
    if not git remote show {{name}} >/dev/null 2>&1
        git remote add {{name}} {{url}}
        # Detect default branch
        git ls-remote --heads {{url}} 2>/dev/null \
        && just cross update_crossfile "cross use {{name}} {{url}}"
    end

# Remove a patch and its worktree
[no-cd]
remove path: check-deps
    #!/usr/bin/env fish
    set l_path "{{path}}"
    pushd "{{REPO_DIR}}"
        if not test -f {{METADATA}}
            just cross _log error "No metadata found."
            exit 1
        end

        set entry (jq -r --arg lp "$l_path" '.patches[] | select(.local_path == $lp)' {{METADATA}})
        if test -z "$entry"
            just cross _log error "Patch not found for path: $l_path"
            exit 1
        end

        set wt (echo "$entry" | jq -r '.worktree')

        just cross _log info "Removing patch at $l_path..."

        # 1. Remove worktree
        if test -d "$wt"
            just cross _log info "Removing git worktree at $wt..."
            git worktree remove --force "$wt"
        end

        # 2. Remove from Crossfile
        just cross _log info "Removing from Crossfile..."
        if test -f "{{CROSSFILE}}"
            set tmp (mktemp)
            grep -v "patch" "{{CROSSFILE}}" > "$tmp"
            grep "patch" "{{CROSSFILE}}" | grep -v "$l_path" >> "$tmp"
            mv "$tmp" "{{CROSSFILE}}"
        end

        # 3. Update metadata
        just cross _log info "Updating metadata..."
        set tmp_meta (mktemp)
        jq --arg lp "$l_path" '.patches |= map(select(.local_path != $lp))' {{METADATA}} > "$tmp_meta"
        mv "$tmp_meta" {{METADATA}}

        # 4. Remove local directory
        just cross _log info "Deleting local directory $l_path..."
        rm -rf "$l_path"

        just cross _log success "Patch removed successfully."
    popd

# AICONTEXT: "patch" will do sparse checkout of specified branch of remote repository into local path. "remote_spec" is in format "remote_name:branch", where "branch" is optional. local_path is the same are remote_path if not provided. Command shall firs use `git ls-remote --heads ` to identify whether remote is having main or master as default branch if not provided - no more evaluation needed, simply grep "refs/heads" with regexp. Tool shall configure sparse checkout and use `git worktree add` and use `".git/cross/worktrees/$remote"_"$hash"` as working directory. Hash shall be short, but shall be created from path and branch name and humans shall ideally read it. checkout either only need maximum of 1 git history (last commmit version). When the checkout is done, "sync" target is called, to sync just this specific "patch" git worktree into main repository to local_path. Then a placeholder is required for post_sync_hook function to run. Finally call `git add` on local_path in top level repo.
# AICONTEXT: for implementation, use "fish" keep it simple, shell comamnds shall be readable. Ideally keep bellow 30 lines. User interaction shall be kept minimal. Debug statements are not needed. Document in comments major logical blocks.
# Patch a directory from a remote into a local path
patch remote_spec local_path="": check-deps
    #!/usr/bin/env fish
    set parts (string split : {{remote_spec}})
    switch (count $parts)
        case 3
            set remote $parts[1]
            set remote_branch $parts[2]
            set remote_path $parts[3]
        case 2
            set remote $parts[1]
            set remote_path $parts[2]
        case '*'
            just cross _log error "Error: Invalid format Use remote[:branch]:remote_path [local_path]"
            exit 1
    end

    # update vars
    set r_path "$remote_path"
    set l_path "{{local_path}}"
    if test -z "$l_path"
        set l_path "$r_path"
    end

    pushd "{{REPO_DIR}}"
    
        # validate remote   
        if not git remote show $remote |grep -vq "^$remote\$" 
            just cross _log error "Error: Remote $remote not found. Run: just use $remote <url>"
            exit 1
        end
        # validate paths
        if test -z "$l_path"; or test "$l_path" = "/";
            just cross _log error "Error: Invalid format Use remote[:branch]:remote_path [local_path]"
            exit 1
        end

        # validate target branch
        if test -z "$remote_branch"
            set remote_branch "master"
            if git ls-remote --heads $remote | grep -q "refs/heads/main"
                set remote_branch "main"
            end
        end
        
        # calculate hash/id
        set hash (echo $l_path | md5sum | cut -d' ' -f1 | cut -c1-8)
        set wt ".git/cross/worktrees/$remote"_"$hash"
        
        # setup worktree
        just cross _log info "Setting up worktree at $wt..."
        if not test -d $wt
            mkdir -p (dirname $wt)
            git fetch $remote $remote_branch
            git worktree add --no-checkout -B "cross/$remote/$remote_branch/$hash" $wt "$remote/$remote_branch" >/dev/null 2>&1

            # Sparse checkout
            git -C $wt sparse-checkout init --no-cone
            git -C $wt sparse-checkout set $r_path
            git -C $wt checkout
        end

        # sync to local_path
        just cross _log info "Syncing files to $l_path..."
        mkdir -p $l_path
        rsync -av --delete --exclude .git $wt/$r_path/ $l_path/

        # Add local_path to git
        git add $l_path
        
        # update Crossfile
        just cross _log info "Update Crossfile"
        just cross update_crossfile "cross patch $remote:$remote_branch:$r_path $l_path"

        # Initialize metadata.json
        if not test -f {{METADATA}}
            mkdir -p (dirname {{METADATA}})
            echo '{"patches": []}' > {{METADATA}}
        end
        # Update metadata.json
        set new_entry "{\"id\": \"$hash\", \"remote\": \"$remote\", \"remote_path\": \"$r_path\", \"local_path\": \"$l_path\", \"worktree\": \"$wt\", \"branch\": \"$remote_branch\"}"
        # 1. Delete existing entry with same id (if any)
        # 2. Append new entry
        set tmp_file (mktemp)
        ## AICONTEXT: use direct update with jq instead the temp file
        jq ".patches |= map(select(.id != \"$hash\")) + [$new_entry]" "{{METADATA}}" > "$tmp_file"
        mv "$tmp_file" "{{METADATA}}"
        
    popd

[no-cd]
@check-initialized:
    cd {{REPO_DIR}} && test -d {{CROSSDIR}}/worktrees && test -f {{METADATA}} \
        || { just cross _log warn "No patches to sync"; exit 0; }

# AICONTEXT: "sync" will sync all or the provided local_path with upstream. Two modes, implemented as sub-sync commands to keep them short. First identify whether local_path has changes. stash them first. Then take the local_path, rsync it to .git/cross/workingtree/ tracking directory. Autogenerate an commit based on git logs for local_path for given range. Commit. Git pull -r from upstream. If coonflicts, cd to $wt and let user to resolve. If not then rsycn WT to local_path, and unstash. Second mode is assumes there are no changes in local_path, so update from remote can happen any time, still some conflict shall happen and user must resolve, so the local_path is still copied to WT before upstream pull -r.
# Sync all patches from upstream
[no-cd]
sync *path="": check-initialized
    #!/usr/bin/env fish
    # Query metadata.json
    just cross _resolve_context2 {{path}} | source \
        || { just cross _log error "Error: Could not resolve metadata for $path."; exit 1; }

    pushd "{{REPO_DIR}}"
        just cross _log info "Syncing $local_path with $worktree..."
        
        # 1. Check for local changes in local_path vs worktree
        # AICONTEXT: the rsync need to sync only git tracked files in $local_path to $worktree/$remote_path
        pushd $local_path
          git ls-files . -z | rsync -0 --files-from=- -av --relative --exclude .git {{REPO_DIR}}/$local_path {{REPO_DIR}}/$worktree/$remote_path
          # FIXME: shall we either use --delete?
        popd 

        # 2. Commit local changes in WT
        set dirty (git -C $worktree status --porcelain)
        if test -n "$dirty"
            just cross _log info "Committing local changes in $worktree..."
            git -C $worktree add .
            git -C $worktree commit -m "Sync local changes"
        end
        
        # 3. Pull rebase from upstream
        just cross _log info "Pulling from upstream..."
        if not git -C $worktree pull --rebase
            just cross _log error "Conflict detected in $worktree. Please resolve manually."
            just cross _log info "cd $$worktree"
            exit 1
        end
        
        # 4. Sync back to local
        just cross _log info "Syncing back to $local_path..."
        pushd $worktree/$remote_path
          git ls-files . -z | rsync -0 --files-from=- -av --relative --exclude .git {{REPO_DIR}}/$worktree/$remote_path {{REPO_DIR}}/$local_path 
        popd

    popd  
        


# AICONTEXT: "diff" will diff local vs .git/cross/worktrees/$remote"_"$hash. It will take all "git tracked" files from local_path and rsync them to .git/cross/worktrees/$remote"_"$hash/$remote_path. This function shall be used by "sync" target to manipulate with files between local_path and WT. When on WT, regular `git diff` can be run. (though then CWD shal return to where user was before the execution, which probably just ensure anyway)
# Diff local vs upstream
[no-cd]
diff path="": check-initialized
    #!/usr/bin/env fish

    # Query metadata.json
    just cross _resolve_context2 "{{path}}" | source \
        || { just cross _log error "Error: Could not resolve metadata for '$path'."; exit 1; }

    pushd "{{REPO_DIR}}"  
        if test -d $worktree
            git diff --no-index $worktree/$remote_path $local_path || true
        else
            just cross _log error "Error: Worktree not found $worktree"
            exit 1
        end
    popd

# AICONTEXT: "push" works on  .git/cross/worktrees/$remote"_"$hash/$remote_path. Input argument is local_path (or understand user stand in the under git-cross'ed local_path and call this comand). The "sync" shall be run first, then regular git push to remote (as pull request, merge request shall happen to remote), the branch to push MR shall be autocalculated ie: "gituser_$hash" used in WT. User shall be give the optino to force-push, as he can repeate. (feature on git-cross)
# Push changes back to upstream
[no-cd]
push path="" branch="" force="false" yes="false" message="": check-initialized
    #!/usr/bin/env fish

    # Query metadata.json
    just cross _resolve_context2 "{{path}}" | source \
        || { just cross _log error "Error: Could not resolve metadata for '$path'."; exit 1; }

    pushd "{{REPO_DIR}}"
        just cross _log warn "The 'push' command is currently WORK IN PROGRESS."
        if not test -d $worktree
            just cross _log error "Error: Worktree not found. Run 'just patch' first."
            exit 1
        end
        
        just cross _log info "Syncing changes from $local_path back to $worktree..."
        rsync -av --delete --exclude .git $local_path/ $worktree/$remote_path/
        
        just cross _log info "---------------------------------------------------"
        just cross _log info "Worktree updated. Status:"
        git -C $worktree status
        just cross _log info "---------------------------------------------------"
        
        while true
            if test "{{yes}}" = "true"
                set choice "r"
            else
                read -P "Run (r), Manual (m), Cancel (c)? " choice
            end

            switch $choice
                case r R
                    just cross _log info "Preparing commit..."
                    pushd $worktree
                        git add .
                        
                        # Determine commit message
                        set msg "{{message}}"
                        
                        if test -z "$msg"; and test "{{yes}}" = "false"
                             read -P "Commit message (empty to auto-generate from local log): " user_msg
                             if test -n "$user_msg"
                                 set msg "$user_msg"
                             end
                        end
                        
                        if test -z "$msg"
                            # Auto-generate from local git log of the path
                            # We need to find the last commit that touched the local_path in the main repo
                            # Note: REPO_DIR is the main repo root
                            set msg (git -C "{{REPO_DIR}}" log -n 1 --pretty=format:%s -- "$local_path")
                            if test -z "$msg"
                                set msg "Sync updates from $local_path"
                            end
                            just cross _log info "Auto-generated message: $msg"
                        end

                        git commit -m "$msg"

                        # Determine push target
                        if test -z "{{branch}}"
                            set upstream (git rev-parse --abbrev-ref --symbolic-full-name '@{upstream}')
                            set remote (string split -m1 / $upstream)[1]
                            set target_branch (string split -m1 / $upstream)[2]
                        else
                            set remote "$remote"
                            set target_branch "{{branch}}"
                        end
                        
                        set push_args "$remote" "HEAD:$target_branch"
                        if test "{{force}}" = "true"
                            set push_args $push_args "--force"
                        end

                        just cross _log info "Pushing to $push_args..."
                        git push $push_args
                    popd >/dev/null
                    break
                case m M
                    just cross _log info "Spawning subshell in $worktree..."
                    just cross _log info "Type 'exit' to return."
                    pushd $worktree
                    fish
                    popd >/dev/null
                    just cross _log info "Returned from manual mode."
                case c C
                    just cross _log warn "Cancelled."
                    exit 0
                case '*'
                    just cross _log error "Invalid choice."
            end
        end
    popd

# AICONTEXT: "list" lists all patches in local repo, by reading Crossfile and `git worktree list` under .git/cross/worktrees. The listing shall be combined with status of each WT and git status of local_path. The logic can be take from "status" implementation.
# List all patches
[no-cd]
list: check-deps
    #!/usr/bin/env fish
    pushd "{{REPO_DIR}}" >/dev/null
        if test -d .git
            just cross _log info "Configured Remotes:"
            git remote -v | awk '{printf "%-20s %-50s %s\n", $1, $2, $3}'
            echo ""
        end

        if not test -f Crossfile
            just cross _log warn "No patches found (Crossfile missing)."
            popd >/dev/null
            exit 0
        end
        
        just cross _log info "Configured Patches:"
        printf "%-20s %-30s %-20s\n" "REMOTE" "REMOTE PATH" "LOCAL PATH"
        printf "%s\n" (string repeat -n 70 "-")
        
        if test -f .git/cross/metadata.json
            jq -r '.patches[] | "\(.remote) \(.remote_path) \(.local_path)"' .git/cross/metadata.json | while read -l remote rpath lpath
                 printf "%-20s %-30s %-20s\n" $remote $rpath $lpath
            end
        else
            just cross _log info "No patches found. Run 'just cross patch <remote> <path>' to start."
        end
    popd >/dev/null

# wt wrapper
[no-cd]
worktree path="":
    just cross cd "{{path}}" dry="{{dry}}"
    
[no-cd]
wt path="":
    just cross cd "{{path}}" dry="{{dry}}"

[no-cd]
cd path="":
    #!/usr/bin/env fish

    # if not initialized, exit
    just cross check-initialized | grep "No patches" && exit 1;

    # try to resolve context (uses "{{path}}" if provided, else CWD)
    just cross _resolve_context2 (string trim -r -c / {{path}}) 2>/dev/null | source || true;

    # if "worktree" is not provided and we are not in a patch, use fzf or just list
    if test -z "$worktree"
        if not command -v fzf >/dev/null
            just cross list
            exit 0
        end

        if test -z "{{dry}}"
            set -l selection (just cross list | tail -n +3 | fzf --select-1 --header "Select patch worktree" --height 40% 2>/dev/null)
            set -l selected_path (echo "$selection" | awk '{print $NF}')
            if test -n "$selected_path"
                just cross cd "$selected_path" dry="{{dry}}"
            end
            exit 0
        else
            just cross list
            exit 0
        end
    end

    just cross _log info "Entering worktree at $worktree, use 'CTRL+D' to return..."
    test -d "{{REPO_DIR}}/$worktree" > /dev/null || exit 1
    set shell "{{SHELL}}"
    if test -z "$shell"
        set shell /bin/sh
    end
    {{dry}} cd "{{REPO_DIR}}/$worktree"
    {{dry}} exec $shell


# AICONTEXT: "status" shows status of current local_path patch vs. WT, and WT upstream. Input argument is local_path (or understand user stand in the under git-cross'ed local_path and call this comand). It shall be called to get status of local_path from "list" command. Either the status of remote WT upstream (as resource consuming, shall be optional or only ocasional)
# Show status of all patches
[no-cd]
status: check-deps
    #!/usr/bin/env fish
    if not test -f Crossfile
        just cross _log warn "No patches found."
        exit 0
    end
    
    printf "%-20s %-15s %-15s %-15s\n" "LOCAL PATH" "DIFF" "UPSTREAM" "CONFLICTS"
    printf "%s\n" (string repeat -n 70 "-")
    
    if test -f .git/cross/metadata.json
        jq -r '.patches[] | "\(.remote) \(.remote_path) \(.local_path) \(.worktree)"' .git/cross/metadata.json | while read -l remote rpath local_path wt
            set diff_stat "Clean"
            set upstream_stat "Synced"
            set conflict_stat "No"
            
            if test -d $wt
                # Check diffs
                if not git diff --no-index --quiet $wt/$rpath $local_path 2>/dev/null
                     set diff_stat "Modified"
                end
                
                # Check upstream divergence
                set behind (git -C $wt rev-list --count HEAD..@{upstream} 2>/dev/null)
                set ahead (git -C $wt rev-list --count @{upstream}..HEAD 2>/dev/null)
                if test "$behind" -gt 0
                    set upstream_stat "$behind behind"
                else if test "$ahead" -gt 0
                    set upstream_stat "$ahead ahead"
                end
                
                # Check conflicts
                if git -C $wt ls-files -u | grep -q .
                    set conflict_stat "YES"
                end
            else
                set diff_stat "Missing WT"
            end
            
            printf "%-20s %-15s %-15s %-15s\n" $local_path $diff_stat $upstream_stat $conflict_stat
        end
    else
        just cross _log info "No patches found."
    end

# Replay commands from Crossfile
replay: check-deps
    /usr/bin/env bash -c "cross() { just --justfile '{{JUST_DIR}}/Justfile' cross \"\$@\"; }; git() { if [ \"\${1-}\" = \"cross\" ]; then shift; cross \"\$@\"; else command git \"\$@\"; fi; }; source '{{REPO_DIR}}/Crossfile'"

# Install git alias for git-cross (impl: go, shell, rust)
install impl="go":
    #!/usr/bin/env bash
    set -e
    export PATH=$HOME/homebrew/bin:$PATH
    case "{{impl}}" in
        go)
            echo "==> Building Go implementation..."
            (cd "{{JUST_DIR}}/src-go" && go build -o git-cross-go main.go)
            EXE="{{JUST_DIR}}/src-go/git-cross-go"
            echo "==> Setting up git alias 'cross' -> $EXE"
            git config --global alias.cross "!$EXE"
            echo "Success: Git alias 'cross' installed."
            ;;
        shell|just)
            CROSS_PATH="{{JUST_DIR}}/Justfile"
            echo "==> Setting up git alias 'cross' -> just --justfile $CROSS_PATH cross"
            git config --global alias.cross "!just --justfile $CROSS_PATH cross"
            echo "Success: Git alias 'cross' installed."
            ;;
        rust)
            echo "==> Building Rust implementation..."
            (cd "{{JUST_DIR}}/src-rust" && cargo build)
            EXE="{{JUST_DIR}}/src-rust/target/debug/git-cross-rust"
            echo "==> Setting up git alias 'cross' -> $EXE"
            git config --global alias.cross-rust "!$EXE"
            echo "Success: Git alias 'cross' installed."
            ;;
        *)
            echo "ERROR: Unknown implementation '{{impl}}'. Use: go, shell, or rust."
            exit 1
            ;;
    esac
